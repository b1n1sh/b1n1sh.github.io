// services/network/public/mojom/auth_and_certificate_observer.mojom.js is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

(function() {
  var mojomId = 'services/network/public/mojom/auth_and_certificate_observer.mojom';
  if (mojo.internal.isMojomLoaded(mojomId)) {
    console.warn('The following mojom is loaded multiple times: ' + mojomId);
    return;
  }
  mojo.internal.markMojomLoaded(mojomId);
  var bindings = mojo;
  var associatedBindings = mojo;
  var codec = mojo.internal;
  var validator = mojo.internal;

  var exports = mojo.internal.exposeNamespace('network.mojom');
  var unguessable_token$ =
      mojo.internal.exposeNamespace('mojoBase.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'mojo/public/mojom/base/unguessable_token.mojom', '../../../../mojo/public/mojom/base/unguessable_token.mojom.js');
  }
  var network_param$ =
      mojo.internal.exposeNamespace('network.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'services/network/public/mojom/network_param.mojom', 'network_param.mojom.js');
  }
  var url$ =
      mojo.internal.exposeNamespace('url.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'url/mojom/url.mojom', '../../../../url/mojom/url.mojom.js');
  }



  function ClientCertificateResponder_ContinueWithCertificate_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  ClientCertificateResponder_ContinueWithCertificate_Params.prototype.initDefaults_ = function() {
    this.x509Certificate = null;
    this.providerName = null;
    this.algorithmPreferences = null;
    this.sslPrivateKey = new SSLPrivateKeyPtr();
  };
  ClientCertificateResponder_ContinueWithCertificate_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  ClientCertificateResponder_ContinueWithCertificate_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 40}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ClientCertificateResponder_ContinueWithCertificate_Params.x509Certificate
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, network_param$.X509Certificate, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ClientCertificateResponder_ContinueWithCertificate_Params.providerName
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 8, false)
    if (err !== validator.validationError.NONE)
        return err;


    // validate ClientCertificateResponder_ContinueWithCertificate_Params.algorithmPreferences
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 16, 2, codec.Uint16, false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate ClientCertificateResponder_ContinueWithCertificate_Params.sslPrivateKey
    err = messageValidator.validateInterface(offset + codec.kStructHeaderSize + 24, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  ClientCertificateResponder_ContinueWithCertificate_Params.encodedSize = codec.kStructHeaderSize + 32;

  ClientCertificateResponder_ContinueWithCertificate_Params.decode = function(decoder) {
    var packed;
    var val = new ClientCertificateResponder_ContinueWithCertificate_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.x509Certificate =
        decoder.decodeStructPointer(network_param$.X509Certificate);
    val.providerName =
        decoder.decodeStruct(codec.String);
    val.algorithmPreferences =
        decoder.decodeArrayPointer(codec.Uint16);
    val.sslPrivateKey =
        decoder.decodeStruct(new codec.Interface(SSLPrivateKeyPtr));
    return val;
  };

  ClientCertificateResponder_ContinueWithCertificate_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(ClientCertificateResponder_ContinueWithCertificate_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(network_param$.X509Certificate, val.x509Certificate);
    encoder.encodeStruct(codec.String, val.providerName);
    encoder.encodeArrayPointer(codec.Uint16, val.algorithmPreferences);
    encoder.encodeStruct(new codec.Interface(SSLPrivateKeyPtr), val.sslPrivateKey);
  };
  function ClientCertificateResponder_ContinueWithoutCertificate_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  ClientCertificateResponder_ContinueWithoutCertificate_Params.prototype.initDefaults_ = function() {
  };
  ClientCertificateResponder_ContinueWithoutCertificate_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  ClientCertificateResponder_ContinueWithoutCertificate_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  ClientCertificateResponder_ContinueWithoutCertificate_Params.encodedSize = codec.kStructHeaderSize + 0;

  ClientCertificateResponder_ContinueWithoutCertificate_Params.decode = function(decoder) {
    var packed;
    var val = new ClientCertificateResponder_ContinueWithoutCertificate_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  ClientCertificateResponder_ContinueWithoutCertificate_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(ClientCertificateResponder_ContinueWithoutCertificate_Params.encodedSize);
    encoder.writeUint32(0);
  };
  function ClientCertificateResponder_CancelRequest_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  ClientCertificateResponder_CancelRequest_Params.prototype.initDefaults_ = function() {
  };
  ClientCertificateResponder_CancelRequest_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  ClientCertificateResponder_CancelRequest_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  ClientCertificateResponder_CancelRequest_Params.encodedSize = codec.kStructHeaderSize + 0;

  ClientCertificateResponder_CancelRequest_Params.decode = function(decoder) {
    var packed;
    var val = new ClientCertificateResponder_CancelRequest_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  ClientCertificateResponder_CancelRequest_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(ClientCertificateResponder_CancelRequest_Params.encodedSize);
    encoder.writeUint32(0);
  };
  function SSLPrivateKey_Sign_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  SSLPrivateKey_Sign_Params.prototype.initDefaults_ = function() {
    this.algorithm = 0;
    this.input = null;
  };
  SSLPrivateKey_Sign_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  SSLPrivateKey_Sign_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;



    // validate SSLPrivateKey_Sign_Params.input
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 8, 1, codec.Uint8, false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  SSLPrivateKey_Sign_Params.encodedSize = codec.kStructHeaderSize + 16;

  SSLPrivateKey_Sign_Params.decode = function(decoder) {
    var packed;
    var val = new SSLPrivateKey_Sign_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.algorithm =
        decoder.decodeStruct(codec.Uint16);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.input =
        decoder.decodeArrayPointer(codec.Uint8);
    return val;
  };

  SSLPrivateKey_Sign_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(SSLPrivateKey_Sign_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Uint16, val.algorithm);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeArrayPointer(codec.Uint8, val.input);
  };
  function SSLPrivateKey_Sign_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  SSLPrivateKey_Sign_ResponseParams.prototype.initDefaults_ = function() {
    this.netError = 0;
    this.signature = null;
  };
  SSLPrivateKey_Sign_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  SSLPrivateKey_Sign_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;



    // validate SSLPrivateKey_Sign_ResponseParams.signature
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 8, 1, codec.Uint8, false, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  SSLPrivateKey_Sign_ResponseParams.encodedSize = codec.kStructHeaderSize + 16;

  SSLPrivateKey_Sign_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new SSLPrivateKey_Sign_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.netError =
        decoder.decodeStruct(codec.Int32);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.signature =
        decoder.decodeArrayPointer(codec.Uint8);
    return val;
  };

  SSLPrivateKey_Sign_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(SSLPrivateKey_Sign_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.netError);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeArrayPointer(codec.Uint8, val.signature);
  };
  function AuthChallengeResponder_OnAuthCredentials_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  AuthChallengeResponder_OnAuthCredentials_Params.prototype.initDefaults_ = function() {
    this.credentials = null;
  };
  AuthChallengeResponder_OnAuthCredentials_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  AuthChallengeResponder_OnAuthCredentials_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate AuthChallengeResponder_OnAuthCredentials_Params.credentials
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, network_param$.AuthCredentials, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  AuthChallengeResponder_OnAuthCredentials_Params.encodedSize = codec.kStructHeaderSize + 8;

  AuthChallengeResponder_OnAuthCredentials_Params.decode = function(decoder) {
    var packed;
    var val = new AuthChallengeResponder_OnAuthCredentials_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.credentials =
        decoder.decodeStructPointer(network_param$.AuthCredentials);
    return val;
  };

  AuthChallengeResponder_OnAuthCredentials_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(AuthChallengeResponder_OnAuthCredentials_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(network_param$.AuthCredentials, val.credentials);
  };
  function AuthenticationAndCertificateObserver_OnSSLCertificateError_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  AuthenticationAndCertificateObserver_OnSSLCertificateError_Params.prototype.initDefaults_ = function() {
    this.url = null;
    this.netError = 0;
    this.fatal = false;
    this.sslInfo = null;
  };
  AuthenticationAndCertificateObserver_OnSSLCertificateError_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  AuthenticationAndCertificateObserver_OnSSLCertificateError_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 32}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate AuthenticationAndCertificateObserver_OnSSLCertificateError_Params.url
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, url$.Url, false);
    if (err !== validator.validationError.NONE)
        return err;



    // validate AuthenticationAndCertificateObserver_OnSSLCertificateError_Params.sslInfo
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, network_param$.SSLInfo, false);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  AuthenticationAndCertificateObserver_OnSSLCertificateError_Params.encodedSize = codec.kStructHeaderSize + 24;

  AuthenticationAndCertificateObserver_OnSSLCertificateError_Params.decode = function(decoder) {
    var packed;
    var val = new AuthenticationAndCertificateObserver_OnSSLCertificateError_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.url =
        decoder.decodeStructPointer(url$.Url);
    val.netError =
        decoder.decodeStruct(codec.Int32);
    packed = decoder.readUint8();
    val.fatal = (packed >> 0) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.sslInfo =
        decoder.decodeStructPointer(network_param$.SSLInfo);
    return val;
  };

  AuthenticationAndCertificateObserver_OnSSLCertificateError_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(AuthenticationAndCertificateObserver_OnSSLCertificateError_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(url$.Url, val.url);
    encoder.encodeStruct(codec.Int32, val.netError);
    packed = 0;
    packed |= (val.fatal & 1) << 0
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStructPointer(network_param$.SSLInfo, val.sslInfo);
  };
  function AuthenticationAndCertificateObserver_OnSSLCertificateError_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  AuthenticationAndCertificateObserver_OnSSLCertificateError_ResponseParams.prototype.initDefaults_ = function() {
    this.netError = 0;
  };
  AuthenticationAndCertificateObserver_OnSSLCertificateError_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  AuthenticationAndCertificateObserver_OnSSLCertificateError_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  AuthenticationAndCertificateObserver_OnSSLCertificateError_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  AuthenticationAndCertificateObserver_OnSSLCertificateError_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new AuthenticationAndCertificateObserver_OnSSLCertificateError_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.netError =
        decoder.decodeStruct(codec.Int32);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  AuthenticationAndCertificateObserver_OnSSLCertificateError_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(AuthenticationAndCertificateObserver_OnSSLCertificateError_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.netError);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function AuthenticationAndCertificateObserver_OnCertificateRequested_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  AuthenticationAndCertificateObserver_OnCertificateRequested_Params.prototype.initDefaults_ = function() {
    this.windowId = null;
    this.certInfo = null;
    this.certResponder = new ClientCertificateResponderPtr();
  };
  AuthenticationAndCertificateObserver_OnCertificateRequested_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  AuthenticationAndCertificateObserver_OnCertificateRequested_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 32}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate AuthenticationAndCertificateObserver_OnCertificateRequested_Params.windowId
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, unguessable_token$.UnguessableToken, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate AuthenticationAndCertificateObserver_OnCertificateRequested_Params.certInfo
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, network_param$.SSLCertRequestInfo, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate AuthenticationAndCertificateObserver_OnCertificateRequested_Params.certResponder
    err = messageValidator.validateInterface(offset + codec.kStructHeaderSize + 16, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  AuthenticationAndCertificateObserver_OnCertificateRequested_Params.encodedSize = codec.kStructHeaderSize + 24;

  AuthenticationAndCertificateObserver_OnCertificateRequested_Params.decode = function(decoder) {
    var packed;
    var val = new AuthenticationAndCertificateObserver_OnCertificateRequested_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.windowId =
        decoder.decodeStructPointer(unguessable_token$.UnguessableToken);
    val.certInfo =
        decoder.decodeStructPointer(network_param$.SSLCertRequestInfo);
    val.certResponder =
        decoder.decodeStruct(new codec.Interface(ClientCertificateResponderPtr));
    return val;
  };

  AuthenticationAndCertificateObserver_OnCertificateRequested_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(AuthenticationAndCertificateObserver_OnCertificateRequested_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(unguessable_token$.UnguessableToken, val.windowId);
    encoder.encodeStructPointer(network_param$.SSLCertRequestInfo, val.certInfo);
    encoder.encodeStruct(new codec.Interface(ClientCertificateResponderPtr), val.certResponder);
  };
  function AuthenticationAndCertificateObserver_OnAuthRequired_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  AuthenticationAndCertificateObserver_OnAuthRequired_Params.prototype.initDefaults_ = function() {
    this.windowId = null;
    this.requestId = 0;
    this.firstAuthAttempt = false;
    this.url = null;
    this.authInfo = null;
    this.headHeaders = null;
    this.authChallengeResponder = new AuthChallengeResponderPtr();
  };
  AuthenticationAndCertificateObserver_OnAuthRequired_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  AuthenticationAndCertificateObserver_OnAuthRequired_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 56}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate AuthenticationAndCertificateObserver_OnAuthRequired_Params.windowId
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, unguessable_token$.UnguessableToken, true);
    if (err !== validator.validationError.NONE)
        return err;



    // validate AuthenticationAndCertificateObserver_OnAuthRequired_Params.url
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, url$.Url, false);
    if (err !== validator.validationError.NONE)
        return err;



    // validate AuthenticationAndCertificateObserver_OnAuthRequired_Params.authInfo
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 24, network_param$.AuthChallengeInfo, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate AuthenticationAndCertificateObserver_OnAuthRequired_Params.headHeaders
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 32, network_param$.HttpResponseHeaders, true);
    if (err !== validator.validationError.NONE)
        return err;


    // validate AuthenticationAndCertificateObserver_OnAuthRequired_Params.authChallengeResponder
    err = messageValidator.validateInterface(offset + codec.kStructHeaderSize + 40, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  AuthenticationAndCertificateObserver_OnAuthRequired_Params.encodedSize = codec.kStructHeaderSize + 48;

  AuthenticationAndCertificateObserver_OnAuthRequired_Params.decode = function(decoder) {
    var packed;
    var val = new AuthenticationAndCertificateObserver_OnAuthRequired_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.windowId =
        decoder.decodeStructPointer(unguessable_token$.UnguessableToken);
    val.requestId =
        decoder.decodeStruct(codec.Uint32);
    packed = decoder.readUint8();
    val.firstAuthAttempt = (packed >> 0) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.url =
        decoder.decodeStructPointer(url$.Url);
    val.authInfo =
        decoder.decodeStructPointer(network_param$.AuthChallengeInfo);
    val.headHeaders =
        decoder.decodeStructPointer(network_param$.HttpResponseHeaders);
    val.authChallengeResponder =
        decoder.decodeStruct(new codec.Interface(AuthChallengeResponderPtr));
    return val;
  };

  AuthenticationAndCertificateObserver_OnAuthRequired_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(AuthenticationAndCertificateObserver_OnAuthRequired_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(unguessable_token$.UnguessableToken, val.windowId);
    encoder.encodeStruct(codec.Uint32, val.requestId);
    packed = 0;
    packed |= (val.firstAuthAttempt & 1) << 0
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStructPointer(url$.Url, val.url);
    encoder.encodeStructPointer(network_param$.AuthChallengeInfo, val.authInfo);
    encoder.encodeStructPointer(network_param$.HttpResponseHeaders, val.headHeaders);
    encoder.encodeStruct(new codec.Interface(AuthChallengeResponderPtr), val.authChallengeResponder);
  };
  function AuthenticationAndCertificateObserver_Clone_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  AuthenticationAndCertificateObserver_Clone_Params.prototype.initDefaults_ = function() {
    this.listener = new bindings.InterfaceRequest();
  };
  AuthenticationAndCertificateObserver_Clone_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  AuthenticationAndCertificateObserver_Clone_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate AuthenticationAndCertificateObserver_Clone_Params.listener
    err = messageValidator.validateInterfaceRequest(offset + codec.kStructHeaderSize + 0, false)
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  AuthenticationAndCertificateObserver_Clone_Params.encodedSize = codec.kStructHeaderSize + 8;

  AuthenticationAndCertificateObserver_Clone_Params.decode = function(decoder) {
    var packed;
    var val = new AuthenticationAndCertificateObserver_Clone_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.listener =
        decoder.decodeStruct(codec.InterfaceRequest);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  AuthenticationAndCertificateObserver_Clone_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(AuthenticationAndCertificateObserver_Clone_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.InterfaceRequest, val.listener);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  var kClientCertificateResponder_ContinueWithCertificate_Name = 304048775;
  var kClientCertificateResponder_ContinueWithoutCertificate_Name = 1077580873;
  var kClientCertificateResponder_CancelRequest_Name = 1555894043;

  function ClientCertificateResponderPtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(ClientCertificateResponder,
                                                   handleOrPtrInfo);
  }

  function ClientCertificateResponderAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        ClientCertificateResponder, associatedInterfacePtrInfo);
  }

  ClientCertificateResponderAssociatedPtr.prototype =
      Object.create(ClientCertificateResponderPtr.prototype);
  ClientCertificateResponderAssociatedPtr.prototype.constructor =
      ClientCertificateResponderAssociatedPtr;

  function ClientCertificateResponderProxy(receiver) {
    this.receiver_ = receiver;
  }
  ClientCertificateResponderPtr.prototype.continueWithCertificate = function() {
    return ClientCertificateResponderProxy.prototype.continueWithCertificate
        .apply(this.ptr.getProxy(), arguments);
  };

  ClientCertificateResponderProxy.prototype.continueWithCertificate = function(x509Certificate, providerName, algorithmPreferences, sslPrivateKey) {
    var params_ = new ClientCertificateResponder_ContinueWithCertificate_Params();
    params_.x509Certificate = x509Certificate;
    params_.providerName = providerName;
    params_.algorithmPreferences = algorithmPreferences;
    params_.sslPrivateKey = sslPrivateKey;
    var builder = new codec.MessageV0Builder(
        kClientCertificateResponder_ContinueWithCertificate_Name,
        codec.align(ClientCertificateResponder_ContinueWithCertificate_Params.encodedSize));
    builder.encodeStruct(ClientCertificateResponder_ContinueWithCertificate_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  ClientCertificateResponderPtr.prototype.continueWithoutCertificate = function() {
    return ClientCertificateResponderProxy.prototype.continueWithoutCertificate
        .apply(this.ptr.getProxy(), arguments);
  };

  ClientCertificateResponderProxy.prototype.continueWithoutCertificate = function() {
    var params_ = new ClientCertificateResponder_ContinueWithoutCertificate_Params();
    var builder = new codec.MessageV0Builder(
        kClientCertificateResponder_ContinueWithoutCertificate_Name,
        codec.align(ClientCertificateResponder_ContinueWithoutCertificate_Params.encodedSize));
    builder.encodeStruct(ClientCertificateResponder_ContinueWithoutCertificate_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  ClientCertificateResponderPtr.prototype.cancelRequest = function() {
    return ClientCertificateResponderProxy.prototype.cancelRequest
        .apply(this.ptr.getProxy(), arguments);
  };

  ClientCertificateResponderProxy.prototype.cancelRequest = function() {
    var params_ = new ClientCertificateResponder_CancelRequest_Params();
    var builder = new codec.MessageV0Builder(
        kClientCertificateResponder_CancelRequest_Name,
        codec.align(ClientCertificateResponder_CancelRequest_Params.encodedSize));
    builder.encodeStruct(ClientCertificateResponder_CancelRequest_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };

  function ClientCertificateResponderStub(delegate) {
    this.delegate_ = delegate;
  }
  ClientCertificateResponderStub.prototype.continueWithCertificate = function(x509Certificate, providerName, algorithmPreferences, sslPrivateKey) {
    return this.delegate_ && this.delegate_.continueWithCertificate && this.delegate_.continueWithCertificate(x509Certificate, providerName, algorithmPreferences, sslPrivateKey);
  }
  ClientCertificateResponderStub.prototype.continueWithoutCertificate = function() {
    return this.delegate_ && this.delegate_.continueWithoutCertificate && this.delegate_.continueWithoutCertificate();
  }
  ClientCertificateResponderStub.prototype.cancelRequest = function() {
    return this.delegate_ && this.delegate_.cancelRequest && this.delegate_.cancelRequest();
  }

  ClientCertificateResponderStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kClientCertificateResponder_ContinueWithCertificate_Name:
      var params = reader.decodeStruct(ClientCertificateResponder_ContinueWithCertificate_Params);
      this.continueWithCertificate(params.x509Certificate, params.providerName, params.algorithmPreferences, params.sslPrivateKey);
      return true;
    case kClientCertificateResponder_ContinueWithoutCertificate_Name:
      var params = reader.decodeStruct(ClientCertificateResponder_ContinueWithoutCertificate_Params);
      this.continueWithoutCertificate();
      return true;
    case kClientCertificateResponder_CancelRequest_Name:
      var params = reader.decodeStruct(ClientCertificateResponder_CancelRequest_Params);
      this.cancelRequest();
      return true;
    default:
      return false;
    }
  };

  ClientCertificateResponderStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    default:
      return false;
    }
  };

  function validateClientCertificateResponderRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kClientCertificateResponder_ContinueWithCertificate_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = ClientCertificateResponder_ContinueWithCertificate_Params;
      break;
      case kClientCertificateResponder_ContinueWithoutCertificate_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = ClientCertificateResponder_ContinueWithoutCertificate_Params;
      break;
      case kClientCertificateResponder_CancelRequest_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = ClientCertificateResponder_CancelRequest_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateClientCertificateResponderResponse(messageValidator) {
    return validator.validationError.NONE;
  }

  var ClientCertificateResponder = {
    name: 'network.mojom.ClientCertificateResponder',
    kVersion: 0,
    ptrClass: ClientCertificateResponderPtr,
    proxyClass: ClientCertificateResponderProxy,
    stubClass: ClientCertificateResponderStub,
    validateRequest: validateClientCertificateResponderRequest,
    validateResponse: null,
  };
  ClientCertificateResponderStub.prototype.validator = validateClientCertificateResponderRequest;
  ClientCertificateResponderProxy.prototype.validator = null;
  var kSSLPrivateKey_Sign_Name = 531793234;

  function SSLPrivateKeyPtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(SSLPrivateKey,
                                                   handleOrPtrInfo);
  }

  function SSLPrivateKeyAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        SSLPrivateKey, associatedInterfacePtrInfo);
  }

  SSLPrivateKeyAssociatedPtr.prototype =
      Object.create(SSLPrivateKeyPtr.prototype);
  SSLPrivateKeyAssociatedPtr.prototype.constructor =
      SSLPrivateKeyAssociatedPtr;

  function SSLPrivateKeyProxy(receiver) {
    this.receiver_ = receiver;
  }
  SSLPrivateKeyPtr.prototype.sign = function() {
    return SSLPrivateKeyProxy.prototype.sign
        .apply(this.ptr.getProxy(), arguments);
  };

  SSLPrivateKeyProxy.prototype.sign = function(algorithm, input) {
    var params_ = new SSLPrivateKey_Sign_Params();
    params_.algorithm = algorithm;
    params_.input = input;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kSSLPrivateKey_Sign_Name,
          codec.align(SSLPrivateKey_Sign_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(SSLPrivateKey_Sign_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(SSLPrivateKey_Sign_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };

  function SSLPrivateKeyStub(delegate) {
    this.delegate_ = delegate;
  }
  SSLPrivateKeyStub.prototype.sign = function(algorithm, input) {
    return this.delegate_ && this.delegate_.sign && this.delegate_.sign(algorithm, input);
  }

  SSLPrivateKeyStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    default:
      return false;
    }
  };

  SSLPrivateKeyStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kSSLPrivateKey_Sign_Name:
      var params = reader.decodeStruct(SSLPrivateKey_Sign_Params);
      this.sign(params.algorithm, params.input).then(function(response) {
        var responseParams =
            new SSLPrivateKey_Sign_ResponseParams();
        responseParams.netError = response.netError;
        responseParams.signature = response.signature;
        var builder = new codec.MessageV1Builder(
            kSSLPrivateKey_Sign_Name,
            codec.align(SSLPrivateKey_Sign_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(SSLPrivateKey_Sign_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    default:
      return false;
    }
  };

  function validateSSLPrivateKeyRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kSSLPrivateKey_Sign_Name:
        if (message.expectsResponse())
          paramsClass = SSLPrivateKey_Sign_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateSSLPrivateKeyResponse(messageValidator) {
   var message = messageValidator.message;
   var paramsClass = null;
   switch (message.getName()) {
      case kSSLPrivateKey_Sign_Name:
        if (message.isResponse())
          paramsClass = SSLPrivateKey_Sign_ResponseParams;
        break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  var SSLPrivateKey = {
    name: 'network.mojom.SSLPrivateKey',
    kVersion: 0,
    ptrClass: SSLPrivateKeyPtr,
    proxyClass: SSLPrivateKeyProxy,
    stubClass: SSLPrivateKeyStub,
    validateRequest: validateSSLPrivateKeyRequest,
    validateResponse: validateSSLPrivateKeyResponse,
  };
  SSLPrivateKeyStub.prototype.validator = validateSSLPrivateKeyRequest;
  SSLPrivateKeyProxy.prototype.validator = validateSSLPrivateKeyResponse;
  var kAuthChallengeResponder_OnAuthCredentials_Name = 163509630;

  function AuthChallengeResponderPtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(AuthChallengeResponder,
                                                   handleOrPtrInfo);
  }

  function AuthChallengeResponderAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        AuthChallengeResponder, associatedInterfacePtrInfo);
  }

  AuthChallengeResponderAssociatedPtr.prototype =
      Object.create(AuthChallengeResponderPtr.prototype);
  AuthChallengeResponderAssociatedPtr.prototype.constructor =
      AuthChallengeResponderAssociatedPtr;

  function AuthChallengeResponderProxy(receiver) {
    this.receiver_ = receiver;
  }
  AuthChallengeResponderPtr.prototype.onAuthCredentials = function() {
    return AuthChallengeResponderProxy.prototype.onAuthCredentials
        .apply(this.ptr.getProxy(), arguments);
  };

  AuthChallengeResponderProxy.prototype.onAuthCredentials = function(credentials) {
    var params_ = new AuthChallengeResponder_OnAuthCredentials_Params();
    params_.credentials = credentials;
    var builder = new codec.MessageV0Builder(
        kAuthChallengeResponder_OnAuthCredentials_Name,
        codec.align(AuthChallengeResponder_OnAuthCredentials_Params.encodedSize));
    builder.encodeStruct(AuthChallengeResponder_OnAuthCredentials_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };

  function AuthChallengeResponderStub(delegate) {
    this.delegate_ = delegate;
  }
  AuthChallengeResponderStub.prototype.onAuthCredentials = function(credentials) {
    return this.delegate_ && this.delegate_.onAuthCredentials && this.delegate_.onAuthCredentials(credentials);
  }

  AuthChallengeResponderStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kAuthChallengeResponder_OnAuthCredentials_Name:
      var params = reader.decodeStruct(AuthChallengeResponder_OnAuthCredentials_Params);
      this.onAuthCredentials(params.credentials);
      return true;
    default:
      return false;
    }
  };

  AuthChallengeResponderStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    default:
      return false;
    }
  };

  function validateAuthChallengeResponderRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kAuthChallengeResponder_OnAuthCredentials_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = AuthChallengeResponder_OnAuthCredentials_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateAuthChallengeResponderResponse(messageValidator) {
    return validator.validationError.NONE;
  }

  var AuthChallengeResponder = {
    name: 'network.mojom.AuthChallengeResponder',
    kVersion: 0,
    ptrClass: AuthChallengeResponderPtr,
    proxyClass: AuthChallengeResponderProxy,
    stubClass: AuthChallengeResponderStub,
    validateRequest: validateAuthChallengeResponderRequest,
    validateResponse: null,
  };
  AuthChallengeResponderStub.prototype.validator = validateAuthChallengeResponderRequest;
  AuthChallengeResponderProxy.prototype.validator = null;
  var kAuthenticationAndCertificateObserver_OnSSLCertificateError_Name = 23730218;
  var kAuthenticationAndCertificateObserver_OnCertificateRequested_Name = 1969716266;
  var kAuthenticationAndCertificateObserver_OnAuthRequired_Name = 440212958;
  var kAuthenticationAndCertificateObserver_Clone_Name = 1749781191;

  function AuthenticationAndCertificateObserverPtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(AuthenticationAndCertificateObserver,
                                                   handleOrPtrInfo);
  }

  function AuthenticationAndCertificateObserverAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        AuthenticationAndCertificateObserver, associatedInterfacePtrInfo);
  }

  AuthenticationAndCertificateObserverAssociatedPtr.prototype =
      Object.create(AuthenticationAndCertificateObserverPtr.prototype);
  AuthenticationAndCertificateObserverAssociatedPtr.prototype.constructor =
      AuthenticationAndCertificateObserverAssociatedPtr;

  function AuthenticationAndCertificateObserverProxy(receiver) {
    this.receiver_ = receiver;
  }
  AuthenticationAndCertificateObserverPtr.prototype.onSSLCertificateError = function() {
    return AuthenticationAndCertificateObserverProxy.prototype.onSSLCertificateError
        .apply(this.ptr.getProxy(), arguments);
  };

  AuthenticationAndCertificateObserverProxy.prototype.onSSLCertificateError = function(url, netError, sslInfo, fatal) {
    var params_ = new AuthenticationAndCertificateObserver_OnSSLCertificateError_Params();
    params_.url = url;
    params_.netError = netError;
    params_.sslInfo = sslInfo;
    params_.fatal = fatal;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kAuthenticationAndCertificateObserver_OnSSLCertificateError_Name,
          codec.align(AuthenticationAndCertificateObserver_OnSSLCertificateError_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(AuthenticationAndCertificateObserver_OnSSLCertificateError_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(AuthenticationAndCertificateObserver_OnSSLCertificateError_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  AuthenticationAndCertificateObserverPtr.prototype.onCertificateRequested = function() {
    return AuthenticationAndCertificateObserverProxy.prototype.onCertificateRequested
        .apply(this.ptr.getProxy(), arguments);
  };

  AuthenticationAndCertificateObserverProxy.prototype.onCertificateRequested = function(windowId, certInfo, certResponder) {
    var params_ = new AuthenticationAndCertificateObserver_OnCertificateRequested_Params();
    params_.windowId = windowId;
    params_.certInfo = certInfo;
    params_.certResponder = certResponder;
    var builder = new codec.MessageV0Builder(
        kAuthenticationAndCertificateObserver_OnCertificateRequested_Name,
        codec.align(AuthenticationAndCertificateObserver_OnCertificateRequested_Params.encodedSize));
    builder.encodeStruct(AuthenticationAndCertificateObserver_OnCertificateRequested_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  AuthenticationAndCertificateObserverPtr.prototype.onAuthRequired = function() {
    return AuthenticationAndCertificateObserverProxy.prototype.onAuthRequired
        .apply(this.ptr.getProxy(), arguments);
  };

  AuthenticationAndCertificateObserverProxy.prototype.onAuthRequired = function(windowId, requestId, url, firstAuthAttempt, authInfo, headHeaders, authChallengeResponder) {
    var params_ = new AuthenticationAndCertificateObserver_OnAuthRequired_Params();
    params_.windowId = windowId;
    params_.requestId = requestId;
    params_.url = url;
    params_.firstAuthAttempt = firstAuthAttempt;
    params_.authInfo = authInfo;
    params_.headHeaders = headHeaders;
    params_.authChallengeResponder = authChallengeResponder;
    var builder = new codec.MessageV0Builder(
        kAuthenticationAndCertificateObserver_OnAuthRequired_Name,
        codec.align(AuthenticationAndCertificateObserver_OnAuthRequired_Params.encodedSize));
    builder.encodeStruct(AuthenticationAndCertificateObserver_OnAuthRequired_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  AuthenticationAndCertificateObserverPtr.prototype.clone = function() {
    return AuthenticationAndCertificateObserverProxy.prototype.clone
        .apply(this.ptr.getProxy(), arguments);
  };

  AuthenticationAndCertificateObserverProxy.prototype.clone = function(listener) {
    var params_ = new AuthenticationAndCertificateObserver_Clone_Params();
    params_.listener = listener;
    var builder = new codec.MessageV0Builder(
        kAuthenticationAndCertificateObserver_Clone_Name,
        codec.align(AuthenticationAndCertificateObserver_Clone_Params.encodedSize));
    builder.encodeStruct(AuthenticationAndCertificateObserver_Clone_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };

  function AuthenticationAndCertificateObserverStub(delegate) {
    this.delegate_ = delegate;
  }
  AuthenticationAndCertificateObserverStub.prototype.onSSLCertificateError = function(url, netError, sslInfo, fatal) {
    return this.delegate_ && this.delegate_.onSSLCertificateError && this.delegate_.onSSLCertificateError(url, netError, sslInfo, fatal);
  }
  AuthenticationAndCertificateObserverStub.prototype.onCertificateRequested = function(windowId, certInfo, certResponder) {
    return this.delegate_ && this.delegate_.onCertificateRequested && this.delegate_.onCertificateRequested(windowId, certInfo, certResponder);
  }
  AuthenticationAndCertificateObserverStub.prototype.onAuthRequired = function(windowId, requestId, url, firstAuthAttempt, authInfo, headHeaders, authChallengeResponder) {
    return this.delegate_ && this.delegate_.onAuthRequired && this.delegate_.onAuthRequired(windowId, requestId, url, firstAuthAttempt, authInfo, headHeaders, authChallengeResponder);
  }
  AuthenticationAndCertificateObserverStub.prototype.clone = function(listener) {
    return this.delegate_ && this.delegate_.clone && this.delegate_.clone(listener);
  }

  AuthenticationAndCertificateObserverStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kAuthenticationAndCertificateObserver_OnCertificateRequested_Name:
      var params = reader.decodeStruct(AuthenticationAndCertificateObserver_OnCertificateRequested_Params);
      this.onCertificateRequested(params.windowId, params.certInfo, params.certResponder);
      return true;
    case kAuthenticationAndCertificateObserver_OnAuthRequired_Name:
      var params = reader.decodeStruct(AuthenticationAndCertificateObserver_OnAuthRequired_Params);
      this.onAuthRequired(params.windowId, params.requestId, params.url, params.firstAuthAttempt, params.authInfo, params.headHeaders, params.authChallengeResponder);
      return true;
    case kAuthenticationAndCertificateObserver_Clone_Name:
      var params = reader.decodeStruct(AuthenticationAndCertificateObserver_Clone_Params);
      this.clone(params.listener);
      return true;
    default:
      return false;
    }
  };

  AuthenticationAndCertificateObserverStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kAuthenticationAndCertificateObserver_OnSSLCertificateError_Name:
      var params = reader.decodeStruct(AuthenticationAndCertificateObserver_OnSSLCertificateError_Params);
      this.onSSLCertificateError(params.url, params.netError, params.sslInfo, params.fatal).then(function(response) {
        var responseParams =
            new AuthenticationAndCertificateObserver_OnSSLCertificateError_ResponseParams();
        responseParams.netError = response.netError;
        var builder = new codec.MessageV1Builder(
            kAuthenticationAndCertificateObserver_OnSSLCertificateError_Name,
            codec.align(AuthenticationAndCertificateObserver_OnSSLCertificateError_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(AuthenticationAndCertificateObserver_OnSSLCertificateError_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    default:
      return false;
    }
  };

  function validateAuthenticationAndCertificateObserverRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kAuthenticationAndCertificateObserver_OnSSLCertificateError_Name:
        if (message.expectsResponse())
          paramsClass = AuthenticationAndCertificateObserver_OnSSLCertificateError_Params;
      break;
      case kAuthenticationAndCertificateObserver_OnCertificateRequested_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = AuthenticationAndCertificateObserver_OnCertificateRequested_Params;
      break;
      case kAuthenticationAndCertificateObserver_OnAuthRequired_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = AuthenticationAndCertificateObserver_OnAuthRequired_Params;
      break;
      case kAuthenticationAndCertificateObserver_Clone_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = AuthenticationAndCertificateObserver_Clone_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateAuthenticationAndCertificateObserverResponse(messageValidator) {
   var message = messageValidator.message;
   var paramsClass = null;
   switch (message.getName()) {
      case kAuthenticationAndCertificateObserver_OnSSLCertificateError_Name:
        if (message.isResponse())
          paramsClass = AuthenticationAndCertificateObserver_OnSSLCertificateError_ResponseParams;
        break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  var AuthenticationAndCertificateObserver = {
    name: 'network.mojom.AuthenticationAndCertificateObserver',
    kVersion: 0,
    ptrClass: AuthenticationAndCertificateObserverPtr,
    proxyClass: AuthenticationAndCertificateObserverProxy,
    stubClass: AuthenticationAndCertificateObserverStub,
    validateRequest: validateAuthenticationAndCertificateObserverRequest,
    validateResponse: validateAuthenticationAndCertificateObserverResponse,
  };
  AuthenticationAndCertificateObserverStub.prototype.validator = validateAuthenticationAndCertificateObserverRequest;
  AuthenticationAndCertificateObserverProxy.prototype.validator = validateAuthenticationAndCertificateObserverResponse;
  exports.ClientCertificateResponder = ClientCertificateResponder;
  exports.ClientCertificateResponderPtr = ClientCertificateResponderPtr;
  exports.ClientCertificateResponderAssociatedPtr = ClientCertificateResponderAssociatedPtr;
  exports.SSLPrivateKey = SSLPrivateKey;
  exports.SSLPrivateKeyPtr = SSLPrivateKeyPtr;
  exports.SSLPrivateKeyAssociatedPtr = SSLPrivateKeyAssociatedPtr;
  exports.AuthChallengeResponder = AuthChallengeResponder;
  exports.AuthChallengeResponderPtr = AuthChallengeResponderPtr;
  exports.AuthChallengeResponderAssociatedPtr = AuthChallengeResponderAssociatedPtr;
  exports.AuthenticationAndCertificateObserver = AuthenticationAndCertificateObserver;
  exports.AuthenticationAndCertificateObserverPtr = AuthenticationAndCertificateObserverPtr;
  exports.AuthenticationAndCertificateObserverAssociatedPtr = AuthenticationAndCertificateObserverAssociatedPtr;
})();